<?php

/**
* @package		ADOS - Automatic Downloading System
* @version		1.3.9 (build 74)
*
* @author		DINI
* @copyright	2007—2008
*
* @name			Пример модуля
*/

/**
* Класс, содержащий базовый набор функций
* для работы с модулем.
*
* @author	DINI
* @version	1.0.0
*/

# Имя класса должно быть вида module_key, где
# key - это выбранный вами ключ модуля

class module_example
{
	/**
	* Путь до исполняемого файла программы
	*
	* @var string
	*/
	
	# В эту переменную записывается путь до исполняемого
	# файла модуля. Например, "/opt/bin/example".
	# Значение записывается автоматически.
	
	var $path 		= "";
	
	/**
	* Текст ошибки
	*
	* @var string
	*/
	
	# В эту переменную нужно записать текст ошибки в случае
	# ее возникновения. Этот текст будет показан пользователю.
	# Значение записывается функциями модуля.

	var $error 		= "";
	
	/**
	* Настройки модуля
	*
	* @var array
	*/
	
	# Сюда записывается массив с настройками модуля, которые
	# были сохранены в БД (см. инструкции по созданию модулей).
	# Ключи массива соответствуют ключам настроек.
	# Значение записывается автоматически.
	
	var $settings 	= array();
	
	/**
	* Текущее состояние закачки
	*
	* @var string
	*/
	
	# Сюда нужно записать сведения о текущем состоянии закачки
	# соответствующей функцией.
	# Значение записывается функциями модуля.

	var $state		= array(	'file_dl_left'	=> 0,
								'file_dl_time'	=> 0,
								'file_dl_speed'	=> 0,
								);
	
	/**
	* Ссылка на переадресацию
	*
	* @var string
	*/
	
	# Сюда записывается ссылка, полученная при переадресации
	# от сервера, с которого выполняется закачка.
	# Значение записывается автоматически.

	var $redirect	= "";
	
	/**
	* Имя файла
	*
	* @var string
	*/
	
	# Сюда записывается имя файла, от сервера, с которого
	# выполняется закачка.
	# Значение записывается автоматически.

	var $filename	= "";
	
	/**
	* Конструктор класса (не страндартный PHP)
	* 
	* Загружает языковые строки для модуля.
	* Всегда возвращает TRUE.
	* 
	* @return	bool			Отметка об успешном выполнении
	*/
	
	# Изначально функция выполняет только загрузку языковых
	# строк модуля.
	# Однако вы можете добавить другие действия, которые должны
	# производиться после инициализации модуля.
	# Нестандартный конструктор используется потому, что в нем
	# уже доступен класс $this->engine, а сам он вызывается после
	# определения переменных данного класса.
	
	function __class_construct()
	{
		$this->engine->load_lang( 'module_example' );
		
		return TRUE;
	}
	
	/**
	* Получение версии программы (стандартная функция)
	* 
	* Делает запрос для получения версии
	* обслуживаемой модулем программы.
	* 
	* @return	string			Номер версии
	* @return 	bool			FALSE
	*/
	
	# Эта функция делает запрос версии программы-качалки и при помощи
	# регулярных выражений обрабатывает ответ на запрос.
	# В случае, если версия не может быть определена (т.е. совпадений
	# регулярного выражения не найдено), то функция возвращает FALSE,
	# делая перед этим запись об ошибке в лог.
	# Функция вызывается для проверки версии программы при каждой
	# инициализации модуля скриптом.
	
	function std_get_program_version()
	{
		exec( escapeshellcmd( "{$this->path} -V" ), $output );
		
		if( !preg_match( "#example ver\. ([0-9\.]+)#i", implode( "", $output ), $match ) )
		{
			# В переменную $this->error записывается языковая строка с текстом
			# ошибки. Обычно, ключи таких строк начинаются с error_
			
			$this->error =& $this->engine->lang['error_module_cant_get_version'];
			
			# Делается запись в журнал с указанием уровня ошибки и ее кодом.
			
			# Уровни ошибок соответствуют уровням детализации журнала:
			# 1 - Ошибка
			# 2 - Предупреждение
			# 3 - Информационное сообщение
			# 4 - Сообщение для режима отладки
			
			# Код ошбки формируется следующим образом:
			# EME_001
			# |||  |
			# |||  `- порядковый номер события данного уровня
			# ||`---- первая буква кода модуля (E - example)
			# |`----- буква, показывающая тип файла (M - module)
			# `------ буква, показывающая уровень события (E - error, W - warning, I - info)
			
			$this->engine->add_log_event( 1, "EME_001" );
			
			return FALSE;
		}
		
		return $match[1];
	}
	
	/**
	* Запуск закачки
	* 
	* Генерирует необходимую строку для автоматического
	* старта закачки CRON'ом.
	* 
	* @param 	array			Параметры закачиваемого файла
	* 
	* @return	array			( 'size'	=> Размер файла,
	* 							  'string'	=> Строка для запуска
	* 							  'name'	=> Имя файла, полученное от сервера
	* 							  'speed'	=> Параметр для ограничения скорости закачки
	* 							  )
	* @return 	bool			FALSE или
	*/
	
	# Эта функция получает массив с информацией о закачиваемом файле и должна
	# возвратить массив с информацией для последующего создания инструкций для
	# запуска закачки CRON'ом.
	# Основная задача функции - сформировать строку параметров для программы-
	# качалки.
	
	function std_download_start( $file )
	{
		//-------------------------------------------------
		// Изменяем адрес ссылки для применения авторизации
		//-------------------------------------------------
		
		# В переменную $link записывается окончательный адрес закачиваемого файла.
		# Если этот адрес получен после переадресации, то он будет находиться в
		# переменной $this->redirect. Если же переменная пуста, то переадресации
		# не было и можно использовать изначальный адрес.
		# Используем экранирования для спецсимволов, которые могут быть в ссылке.
		
		$link = $this->redirect ? $this->redirect : $file['file_link'];
		$link = escapeshellcmd( preg_replace( "#\s+#", "%20", urldecode( $link ) ) );
		$link = str_replace( array( "'", '"' ), array( "\'", '\"' ), $link );
		$link = str_replace( array( "\\'", '\\"' ), array( "\'", '\"' ), $link );
		
		# В переменной $this->auth находится информация о логине и пароле пользователя,
		# которые должны использоваться при данной закачке (если необходимо).
		# Строка, находящаяся в переменной, имеет вид login@password.
		# Используем экранирования для спецсимволов, которые могут быть в пароле.
		
		if( $this->auth ) $link .= " --use_auth_params=".escapeshellcmd( $this->auth );
		
		//-------------------------------------------------
		// Проверяем, не является ли размер файла нулевым
		//-------------------------------------------------
		
		# Если мы работаем с файлом нулевого размера, то логичнее сообщить об
		# ошибке, т.к. скачивать нечего.
		# Об ошибках см. комментарии к функции std_get_program_version()
		# Третьим параметром функции add_log_event будет массив с информацией
		# для отладки. Эта информация будет всегда доступна администраторам и
		# при включенной опции в настройках - пользователям системы.
		
		if( $file['file_size'] == 0 )
		{
			$this->error = &$this->engine->lang['error_null_file_size'];
			
			$this->engine->add_log_event( 1, "EME_002", array( 'file_id' => $file['file_id'], 'file_name' => $file['file_name'], 'file_dl_id' => $file['file_dl_id'] ) );
			
			return FALSE;
		}
		
		# Если же размер файла не нулевой, то конкретный размер можно записать в журнал
		# для отладки. Чтобы, например, можно было проверить, насколько превышена дисковая
		# квота, если файл не сможет быть скачан из-за нехватки места на диске.
		
		$this->engine->add_log_event( 4, "IME_001", array( 'file_size' => $file['file_size'] ) );
		
		//-------------------------------------------------
		// Формируем и возвращаем строку для начала закачки
		//-------------------------------------------------
		
		# Если же размер файла не нулевой, то конкретный размер можно записать в журнал
		# для отладки. Чтобы, например, можно было проверить, насколько превышена дисковая
		# квота, если файл не сможет быть скачан из-за нехватки места на диске.
		
		return array( 'size'	=> $file['file_size'],
					  'string'	=> $this->settings['engine_path']." --download_link={$link} --output_file={$this->engine->config['save_path']}/_tmp/{$file['file_id']}_{$file['file_user']}_{$file['file_dl_id']}.ados",
					  'name'	=> $this->filename,
					  'speed'	=> "--limit-rate",
					  );
	}
	
	/**
	* Возобновление закачки
	* 
	* Вызывает функцию начала закачки и изменяет полученную
	* строку с параметрами запуска для автоматического
	* возобновления закачки модулем.
	* Для данной функции необходимо наличие идентификатора файла.
	* 
	* @param 	array			Параметры закачиваемого файла
	* @param 	mixed			Параметры авторизации
	* 
	* @return	string			Строка для запуска
	* @return 	bool			FALSE
	*/
	
	# Эта функция аналогична функции std_download_start() с тем лишь
	# отличием, что в возвращаемый массив к строке параметров запуска
	# закачки добавляется параметр, показывающий программе-качалке
	# необходимость ее возобновления.
	# Используйте эту функцию только если докачка файла поддерживается
	# программой-качалкой.
	
	/*
	function std_download_continue( $file )
	{
		$params = $this->std_download_start( &$file );
		
		$params['string'] .= " --continue";
		
		return $params;
	}
	*/
	
	/**
	* Приостановка закачки
	* 
	* Алиас функции остановки закачки.
	* 
	* @param 	array			Параметры закачиваемого файла
	* 
	* @return 	bool			Результат выполнения операции
	*/
	
	# Эта функция аналогична функции std_download_stop() (ниже).
	# Используйте эту функцию только если программа-качалка поддерживает
	# дальнейшую докачку файлов.
	
	/*
	function std_download_pause( $file )
	{
		return $this->std_download_stop( &$file, FALSE );
	}
	*/
	
	/**
	* Остановка закачки
	* 
	* Выполняет поиск процессов, осуществляющих закачку, и
	* отменяет их. Также удаляет CRON файл, если он
	* существует.
	* 
	* @param 	array			Параметры закачиваемого файла
	* @param 	bool			Удалить лог закачки
	* 
	* @return 	bool			Результат выполнения операции
	*/
	
	# Эта функция убивает все процессы системы, связанные с закачкой
	# данного файла.
	# Функция универсальна для любого модуля.
	
	function std_download_stop( $file, $delete_log=TRUE )
	{
		if( !preg_match( "#^[a-zA-Z0-9]{32}$#", $file['file_dl_id'] ) )
		{
			# Сообщение об ошибке в случае, если получен неверный идентификатор закачки.
			
			$this->error =& $this->engine->lang['error_wrong_file_dl_id'];
			
			return FALSE;
		}
		
		//-------------------------------------------------
		// Останавливаем закачку
		//-------------------------------------------------
		
		$output = shell_exec( "ps -ww" );
		
		if( preg_match_all( "#\s*(\d+).+{$file['file_dl_id']}\.ados#", $output, $match, PREG_SET_ORDER ) ) foreach( $match as $pid )
		{
			$pids[] = $pid[1];
		}
		
		if( is_array( $pids ) ) exec( "kill ".implode( " ", $pids ) );
		
		//-------------------------------------------------
		// Удаляем CRON файл
		//-------------------------------------------------
		
		if( $this->engine->classes['downloader']->_delete_cron_file( $file['file_dl_id'] ) === FALSE )
		{
			return FALSE;
		}
		
		//-------------------------------------------------
		// Удаляем лог закачки
		//-------------------------------------------------
		
		if( $delete_log === TRUE )
		{
			@unlink( $this->engine->config['save_path']."/_log/{$file['file_dl_id']}.log" );
		}
		
		return TRUE;
	}
	
	/**
	* Проверка состояния закачки
	* 
	* Выполняет поиск процессов, осуществляющих закачку.
	* Если они не найдены, то проверяет, закачан ли файл
	* полностью.
	* 
	* @param 	array			Параметры закачиваемого файла
	* 
	* @return 	bool			Результат выполнения операции
	*/
	
	# Эта функция проверяет, идет ли закачка файла в данный момент
	# или же закачка файла еще не происходит, но должна быть запущена
	# позже.
	# Функция универсальна для любого модуля.
	
	function std_download_is_running( $file )
	{
		if( !preg_match( "#^[a-zA-Z0-9]{32}$#", $file['file_dl_id'] ) )
		{
			$this->error = 2;
			
			# Сообщение об ошибке в случае, если получен неверный идентификатор закачки.
			
			$this->engine->add_log_event( 1, "EME_003", array( 'file_id' => $file['file_id'], 'file_name' => $file['file_name'], 'file_dl_id' => $file['file_dl_id'] ) );
			
			return FALSE;
		}
		
		//-------------------------------------------------
		// Проверяем процессы
		//-------------------------------------------------
		
		$output = shell_exec( "ps -ww" );
		
		if( preg_match_all( "#\s*(\d+).+{$file['file_dl_id']}\.ados#", $output, $match, PREG_SET_ORDER ) ) foreach( $match as $pid )
		{
			$pids[] = $pid[1];
		}
		
		if( is_array( $pids ) )
		{
			# Сообщение о том, что закачка идет в данный момент.
			
			$this->engine->add_log_event( 4, "IME_002", array( 'file_id' => $file['file_id'], 'file_name' => $file['file_name'], 'file_dl_id' => $file['file_dl_id'] ) );
			
			//-------------------------------------------------
			// Проверяем, нет ли простоя
			//-------------------------------------------------
			
			if( $this->engine->config['restart_after'] )
			{
				return $this->engine->classes['downloader']->download_restart( &$file );
			}
		}
		
		//-------------------------------------------------
		// Процессов нет, проверяем скачан ли файл
		//-------------------------------------------------
		
		$this->std_get_download_info( &$file );
		
		if( $this->state['file_dl_left'] )
		{
			$this->error = 1;
			
			# Сообщение о том, что файл еще не скачан полностью.
			
			$this->engine->add_log_event( 3, "IME_003", array( 'file_id' => $file['file_id'], 'file_name' => $file['file_name'], 'file_dl_id' => $file['file_dl_id'] ) );
		}
		
		# Сообщение о том, что зкакчка файла в данный момент не происходит.
		
		$this->engine->add_log_event( 4, "IME_004", array( 'file_id' => $file['file_id'], 'file_name' => $file['file_name'], 'file_dl_id' => $file['file_dl_id'] ) );
		
		return FALSE;
	}
	
	/**
	* Обновление параметров закачки
	* 
	* Считывает и записывает информацию из журнала
	* закачки.
	* 
	* @param 	string			Параметры закачиваемого файла
	* 
	* @return 	bool			Результат выполнения операции
	*/
	
	# Эта функция анализирует журнал закачки и на основе анализа последней
	# имеющейся в журнале строки записывает в массив $this->state данные
	# о текущем состоянии.
	
	function std_get_download_info( $file )
	{
		# Сбрасываем текущие элементы.
		
		$this->_clear_state();
		
		# Определяем путь до временного файла.
		
		$save = $this->engine->config['save_path']."/_tmp/{$file['file_id']}_{$file['file_user']}_{$file['file_dl_id']}.ados";
		
		//-------------------------------------------------
		// Проверяем переданный идентификатор
		//-------------------------------------------------
		
		if( !preg_match( "#^[a-zA-Z0-9]{32}$#", $file['file_dl_id'] ) )
		{
			# Сообщение об ошибке в случае, если получен неверный идентификатор закачки.
			
			$this->error =& $this->engine->lang['error_wrong_file_dl_id'];
			
			$this->engine->add_log_event( 1, "EME_004", array( 'file_id' => $file['file_id'], 'file_name' => $file['file_name'], 'file_dl_id' => $file['file_dl_id'] ) );
			
			return FALSE;
		}
		
		//-------------------------------------------------
		// Проверяем наличие журнала закачки
		//-------------------------------------------------
		
		# Определяем путь до журнального файла.
		
		$log = $this->engine->config['save_path']."/_log/{$file['file_dl_id']}.log";
		
		# Если файла нет, то закачка либо закончена, либо еще не начиналась.
		# Далее записываем в качестве значений массива либо нули (если нет файла закачки,
		# т.е. закачка еще не началась), либо нули и размер файла (если файл есть, т.е.
		# закачка уже завершилась).
		
		if( !file_exists( $log ) )
		{
			$exists = file_exists( $save );
			
			$this->state['file_dl_left']  = $exists ? $file['file_size'] - filesize( $save ) : $file['file_size'];
			$this->state['file_dl_time']  = $exists ? 0 : $file['file_dl_time'];
			$this->state['file_dl_speed'] = $exists ? 0 : $file['file_dl_speed'];
			
			$this->engine->add_log_event( 4, "IMC_005", array(	'file_id'		=> $file['file_id'],
																'file_name'		=> $file['file_name'],
																'file_dl_id'	=> $file['file_dl_id'],
																'file_dl_left'	=> $this->state['file_dl_left'],
																'file_dl_time'	=> $this->state['file_dl_time'],
																'file_dl_speed'	=> $this->state['file_dl_speed']
																)	);
			
			return TRUE;
		}
		
		//-------------------------------------------------
		// Считываем первые строки с информацией
		//-------------------------------------------------
		
		# В первых строках журнала может содержаться важная информация,
		# записанная программой-качалкой или сообщения об ошибках, например,
		# при соединении с удаленным сервером.
		
		$string = file_get_contents( $log, NULL, NULL, 0, 1024 );
		
		if( preg_match( "#^Cannot continue because of error \[number (\d+)\].$#m", $string, $error ) )
		{
			# Если в журнале присутствует информация об ошибке, то можно
			# остановить закачку и записать информацию в журнал.
			# Поведение модуля в данной ситуации нужно регулировать в 
			# зависимости от серьезности найденной ошибки.
			
			$this->std_download_stop( $file );
			
			$this->error =& $this->engine->lang['error_internal'];
			
			$this->engine->add_log_event( 1, "EME_005", array( 'file_id' => $file['file_id'], 'file_name' => $file['file_name'], 'file_dl_id' => $file['file_dl_id'], 'error_desc' => $match[1] ) );
			
			return FALSE;
		}
		
		//-------------------------------------------------
		// Считываем последнюю строку с информацией
		//-------------------------------------------------
		
		$string = file_get_contents( $log, NULL, NULL, filesize( $log ) - 1024, 1024 );
		
		# Анализируем последнюю строку журнала.
		# При помощи регулярных выражений получаем данные о скорости закачки, размере уже
		# закачанного файла и т.д.
		# В итоге мы должны получить три параметра:
		#	1. Текущую скорость закачки
		#	2. Оставшееся время закачки
		#	3. Оставшееся количество байт для закачки
		
		preg_match_all( "#(\d+) (\d+) (\d+)#i", $string, $match, PREG_SET_ORDER );
		
		$match = $match[ count( $match ) - 1 ];
		
		//-------------------------------------------------
		// Обрабатываем полученные параметры
		//-------------------------------------------------
		
		# Если анализ последней строки журнала не дал результатов, то можно записать информацию
		# об этом в журнал и вернуть FALSE.
		
		if( !is_array( $match ) )
		{
			$this->error =& $this->engine->lang['error_cant_update_info'];
			
			$this->engine->add_log_event( 1, "EME_006", array( 'file_id' => $file['file_id'], 'file_name' => $file['file_name'], 'file_dl_id' => $file['file_dl_id'] ) );
			
			return FALSE;
		}
		
		# Далее следует сделать обработку полученной в результате обработки журнала информации
		# и вычислить необходимые параметры (см. выше).
		
		$this->state['file_dl_left']  = $match[1];
		$this->state['file_dl_time']  = $match[2];
		$this->state['file_dl_speed'] = $match[3];
		
		//-------------------------------------------------
		// Сохраняем информацию
		//-------------------------------------------------
		
		# После того, как информация о состоянии закачки получена можно сделать запись в журнал
		# для отладки.
		
		$this->engine->add_log_event( 4, "IME_006", array(	'file_id'		=> $file['file_id'],
															'file_name'		=> $file['file_name'],
															'file_dl_id'	=> $file['file_dl_id'],
															'file_dl_left'	=> $this->state['file_dl_left'],
															'file_dl_time'	=> $this->state['file_dl_time'],
															'file_dl_speed'	=> $this->state['file_dl_speed']
															)	);
	}
	
	//-------------------------------------------------
	
	# Сюда можно добавлять дополнительные (нестандартные) функции
	# модуля, которые могут вызываться функциями стандартными.
	
	/**
	* Очистка информации о файле
	* 
	* Очищает массив с информацией о текущем файле с тем,
	* чтобы в нем не осталась информация о предыдущем файле.
	* 
	* @return	void
	*/
	
	function _clear_state()
	{
		$this->state = array(	'file_dl_left'	=> 0,
								'file_dl_time'	=> 0,
								'file_dl_speed'	=> 0,
								);
	}
}

?>